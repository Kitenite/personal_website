{"ast":null,"code":"import _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport React from \"react\";\nvar __jsx = React.createElement;\nimport { useState, useRef, useEffect } from 'react';\nimport SignatureCanvas from 'react-signature-canvas';\nimport Button from '../../../components/Button';\nimport ResultGraph from './ResultGraph';\nexport default function DrawingCanvas() {\n  // useStates\n  const sigCanvas = useRef({});\n  const {\n    0: imageURL,\n    1: setImageURL\n  } = useState(null);\n  const {\n    0: resultArray,\n    1: setResultArray\n  } = useState(null);\n  const {\n    0: height,\n    1: setHeight\n  } = useState(null);\n  const {\n    0: width,\n    1: setWidth\n  } = useState(null); // Canvas Configuration\n\n  if (false) {\n    useEffect(() => setHeight(document.children[0].clientHeight), [document.children[0].clientHeight]);\n    useEffect(() => setWidth(document.children[0].clientWidth), [document.children[0].clientWidth]);\n  }\n\n  const canvasWidth = Math.min(height, width) / 2;\n  const brushSize = (canvasWidth / 30).toString(10); // Functions\n\n  const clearPad = () => {\n    sigCanvas.current.clear();\n    setImageURL(null);\n    setResultArray(null);\n  };\n\n  const submitPad = () => {\n    let submittedImage = sigCanvas.current.getTrimmedCanvas();\n    let result = processImage(submittedImage);\n    apiCall(result[1]);\n    setImageURL(result[0].toDataURL(\"image/png\"));\n  }; // Query our AI model\n\n\n  const apiCall = image_array => {\n    const model_url = '/api/v1/models/digit_model:predict';\n    var xhr = new XMLHttpRequest();\n    xhr.withCredentials = false; // get a callback when the server responds\n\n    xhr.addEventListener('load', () => {\n      // Get results and process\n      if (xhr.responseText) {\n        let reponse = JSON.parse(xhr.responseText);\n        processResult(reponse);\n      }\n    });\n    xhr.open('POST', model_url);\n    xhr.send(_JSON$stringify({\n      \"instances\": image_array\n    }));\n  };\n\n  const processResult = reponse => {\n    let unsorted_array = reponse[\"predictions\"][0];\n    let sorted_array = Array(unsorted_array.length); // Get all results above 0.00%\n\n    for (var i = 0; i < unsorted_array.length; i++) {\n      let index = unsorted_array.indexOf(Math.max(...unsorted_array));\n      let confidence = (unsorted_array[index] * 100).toFixed(2);\n\n      if (confidence > 1) {\n        sorted_array[i] = [index, confidence];\n        unsorted_array[index] = 0;\n      }\n    }\n\n    setResultArray(sorted_array);\n  };\n\n  const processImage = img => {\n    // Scale image\n    const canvas = document.createElement('canvas');\n    const scale = Math.min(20 / img.width, 20 / img.height);\n    canvas.width = 28;\n    canvas.height = 28;\n    const cctx = canvas.getContext('2d');\n    cctx.imageSmoothingEnabled = true;\n    const scaled_width = img.width * scale;\n    const scaled_height = img.height * scale;\n    const dx = (28 - scaled_width) / 2;\n    const dy = (28 - scaled_height) / 2;\n    cctx.drawImage(img, dx, dy, scaled_width, scaled_height); // Turn into 2D array of 28x28\n\n    const image_array = Array(28);\n    var column_count = 0;\n    var row_count = 0;\n    var column_array = Array(28); // invert colors, make black and white and remove alpha\n\n    var imgData = cctx.getImageData(0, 0, canvas.width, canvas.height);\n    var i;\n\n    for (i = 0; i < imgData.data.length; i += 4) {\n      // Fill array\n      if (column_count >= 28) {\n        column_count = 0;\n        image_array[row_count] = column_array; // Reset column_array\n\n        column_array = Array(28);\n        row_count++;\n      }\n\n      if (imgData.data[i + 3] > 0) {\n        // Used to visualize image for debugging, can be discarded\n        imgData.data[i] = 255;\n        imgData.data[i + 1] = 255;\n        imgData.data[i + 2] = 255; // Convert to either 0 or 1\n\n        column_array[column_count] = 1;\n      } else {\n        // Used to visualize image for debugging, can be discarded\n        imgData.data[i] = 0;\n        imgData.data[i + 1] = 0;\n        imgData.data[i + 2] = 0; // Convert to either 0 or 1\n\n        column_array[column_count] = 0;\n      }\n\n      imgData.data[i + 3] = 255;\n      column_count++;\n    } // Lazy add final row empty\n\n\n    var final_row = Array(28);\n\n    for (var i = 0; i < final_row.length; i++) {\n      final_row[i] = 0;\n    }\n\n    image_array[27] = final_row; // Print out array\n    // console.log(image_array);\n\n    cctx.putImageData(imgData, 0, 0);\n    let newImage = canvas;\n    return [newImage, image_array];\n  };\n\n  const result_graph = resultArray => {\n    return __jsx(ResultGraph, {\n      result: resultArray\n    });\n  };\n\n  return __jsx(\"div\", null, __jsx(SignatureCanvas, {\n    ref: sigCanvas,\n    penColor: \"black\",\n    velocityFilterWeight: \"0\",\n    maxWidth: brushSize,\n    dotSize: \"0\",\n    canvasProps: {\n      width: canvasWidth,\n      height: canvasWidth,\n      className: 'signatureCanvas'\n    }\n  }), __jsx(\"div\", {\n    className: \"button-wrapper\"\n  }, __jsx(Button, {\n    className: \"button\",\n    onClick: clearPad,\n    isClear: \"true\"\n  }, \"clear\"), __jsx(Button, {\n    className: \"button\",\n    onClick: submitPad\n  }, \"submit\")), resultArray ? __jsx(\"div\", null, result_graph(resultArray)) : null, imageURL ? __jsx(React.Fragment, null, __jsx(\"p\", null, \"Processed Digit\"), __jsx(\"img\", {\n    src: imageURL,\n    alt: \"my signature\",\n    style: {\n      display: \"block\",\n      margin: \"0 auto\",\n      border: \"1px solid black\",\n      width: \"150px\"\n    }\n  })) : null);\n}","map":null,"metadata":{},"sourceType":"module"}